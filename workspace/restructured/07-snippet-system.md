# ReedCMS Snippet System

## Das Snippet-Konzept

Ein Snippet ist der fundamentale Content-Baustein in ReedCMS. Jeder Inhalt - vom einfachen Text bis zur komplexen Galerie - ist ein Snippet.

**Definition:** Ein Snippet ist eine wiederverwendbare Content-Komponente, die automatisch als Web Component registriert wird.

## Simplified File Pattern

Jedes Snippet besteht aus zwei erforderlichen und einer optionalen Datei:

```bash
snippets/{snippet-name}/
├── {snippet-name}.tera    # Template + Component Definition (required)
├── {snippet-name}.css     # Styling (required)
└── {snippet-name}.js      # Enhancement/Interactivity (optional)
```

### Build-Zeit Generation

```bash
# reed build generiert automatisch:
dist/snippets/
├── components.js          # Alle generierten Web Components
├── hero-banner.js         # Generated Component + optional Enhancement
├── text-block.js          # Generated Component (no enhancement)
└── gallery.js             # Generated Component + optional Enhancement
```

### Die .tera Datei - Template mit Web Component Definition

```tera
{# hero-banner.tera #}
{# @component
    name: "hero-banner"
    attributes: ["title", "subtitle", "theme"]
    slots: ["actions", "footer"]
    shadow: true
#}
{# Rust generiert: Alle attributes werden automatisch als HTML-Attribute gesetzt #}
<h1>{{ title }}</h1>
{% if subtitle %}
    <p class="subtitle">{{ subtitle }}</p>
{% endif %}
<slot name="actions"></slot>
```

### Rust-generierte Web Components

```rust
// Rust generiert das JavaScript zur Build-Zeit
impl SnippetComponentGenerator {
    pub fn generate_component_js(snippet_def: &SnippetDefinition) -> String {
        format!(r#"
// Auto-generated by ReedCMS
class {class_name} extends HTMLElement {{
    static get observedAttributes() {{
        return {attributes};
    }}
    
    constructor() {{
        super();
        {shadow_init}
        this._data = {{}};
    }}
    
    connectedCallback() {{
        this.render();
        {enhancement_call}
    }}
    
    attributeChangedCallback(name, oldValue, newValue) {{
        if (oldValue !== newValue) {{
            this._data[name] = newValue;
            this.render();
        }}
    }}
    
    render() {{
        const target = {render_target};
        target.innerHTML = `
            <link rel="stylesheet" href="/snippets/{name}/{name}.css">
            ${{this._renderTemplate()}}
        `;
    }}
    
    _renderTemplate() {{
        // Tera template rendering with this._data
        return window.reedCMS.renderSnippet('{name}', this._data);
    }}
}}

customElements.define('{tag_name}', {class_name});
"#,
            class_name = snippet_to_js_class(&snippet_def.name),
            tag_name = &snippet_def.name,
            name = &snippet_def.name,
            attributes = serde_json::to_string(&snippet_def.attributes).unwrap(),
            shadow_init = if snippet_def.shadow { 
                "this.attachShadow({ mode: 'open' });" 
            } else { 
                "" 
            },
            render_target = if snippet_def.shadow { 
                "this.shadowRoot" 
            } else { 
                "this" 
            },
            enhancement_call = if snippet_def.has_enhancement_js {
                &format!("import('/snippets/{0}/{0}.js').then(m => m.enhance?.(this));", snippet_def.name)
            } else {
                ""
            }
        )
    }
}
```

### Die .js Datei - Nur noch für Interaktivität (optional)

```javascript
// hero-banner.js - NUR wenn spezielle Interaktivität benötigt wird
export function enhance(element) {
    // Add specific interactive behavior
    element.querySelector('button')?.addEventListener('click', () => {
        console.log('Hero action clicked');
    });
}
```

### Resultat im Browser DOM

```html
<!-- Input: ReedCMS rendert mit Daten -->
{{ render_snippet("hero-banner", {
    title: "Willkommen bei ReedCMS",
    subtitle: "Das KISS-Brain CMS",
    theme: "dark"
}) }}

<!-- Output: So sieht es im Browser aus -->
<hero-banner 
    class="hero-banner" 
    title="Willkommen bei ReedCMS"
    subtitle="Das KISS-Brain CMS"
    theme="dark">
    #shadow-root (open)
        <link rel="stylesheet" href="/snippets/hero-banner/hero-banner.css">
        <h1>Willkommen bei ReedCMS</h1>
        <p class="subtitle">Das KISS-Brain CMS</p>
        <slot name="actions">
            <!-- User content gets slotted here -->
        </slot>
</hero-banner>

<!-- Komplexeres Beispiel -->
<product-showcase
    category="electronics"
    max="6"
    layout="grid"
    class="featured-products">
    <!-- Generierter Content basierend auf Attributen -->
</product-showcase>
```

### Die .css Datei - Styling mit @scope

```css
/* hero-banner.css - Nutzt native CSS @scope */
@scope (hero-banner) {
    :scope {
        display: block;
        padding: 4rem 2rem;
        text-align: center;
    }
    
    h1 {
        font-size: 3rem;
        margin: 0;
    }
    
    .subtitle {
        font-size: 1.5rem;
        opacity: 0.8;
        margin-top: 1rem;
    }
}

/* Breakpoint-spezifische Styles */
@scope (.wcag) {
    hero-banner {
        padding: 2rem 1rem;
    }
    
    hero-banner h1 {
        font-size: 2rem;
        line-height: 1.5;
    }
    
    hero-banner .subtitle {
        font-size: 1.2rem;
    }
}

@scope (.phone) {
    hero-banner {
        padding: 1rem;
    }
    
    hero-banner h1 {
        font-size: 1.75rem;
    }
}
```

## Naming Conventions

### Primäres Muster: kebab-case

Alle Snippet-Namen folgen dem kebab-case Pattern:
- `hero-banner`
- `text-with-image`
- `product-showcase`
- `navigation-item`

### Transformationsregeln

| Kontext | Transformation | Beispiel |
|---------|---------------|----------|
| Snippet-Name | kebab-case | `hero-banner` |
| JS-Klasse | PascalCase + "Snippet" | `HeroBannerSnippet` |
| Web Component | kebab-case (direkt) | `<hero-banner>` |
| CSS-Selektor | kebab-case (direkt) | `hero-banner { }` |
| Dateinamen | kebab-case + Extension | `hero-banner.tera` |
| Semantic Name | $ + snake_case | `$hero_banner` |

### Automatische Transformation

```rust
pub fn snippet_to_js_class(snippet_name: &str) -> String {
    snippet_name
        .split('-')
        .map(|word| format!("{}{}", 
            word.chars().next().unwrap().to_uppercase(), 
            &word[1..].to_lowercase()))
        .collect::<String>() + "Snippet"
}
```

## Snippet vs. Traditionelle Ansätze

### Traditionelles CMS

```php
// Wordpress-Style: Chaos durch Plugins
function render_hero($title, $subtitle, $background) {
    echo '<div class="hero" style="background:' . $background . '">';
    echo '<h1>' . esc_html($title) . '</h1>';
    if ($subtitle) {
        echo '<p>' . esc_html($subtitle) . '</p>';
    }
    echo '</div>';
}
// Jedes Plugin macht es anders!
```

### ReedCMS Snippet-System

```rust
// Einheitlich, vorhersehbar, type-safe
pub struct Snippet {
    pub snippet_type: String,      // "hero-banner"
    pub data: serde_json::Value,   // Validated fields
    pub semantic_name: Option<String>, // "$welcome_hero"
}

// IMMER gleiche Struktur, IMMER gleiche Files
```

## @component Directive

Die @component Directive im Tera-Template definiert die Web Component:

```tera
{# @component
    name: "product-showcase"         # Web Component Tag Name
    attributes: ["category", "max"]  # Reactive Attributes
    slots: ["header", "footer"]      # Named Slots
    shadow: false                    # No Shadow DOM for this one
    fields: {                        # Field Definitions for Registry
        "category": "String",
        "max": "Number(min:1;max:20)",
        "layout": "String(enum:grid,list)"
    }
#}
```

### Minimales Beispiel

```tera
{# simple-text.tera #}
{# @component name: "simple-text" #}
<simple-text>
    <p>{{ content }}</p>
</simple-text>
```

Das reicht! ReedCMS registriert automatisch eine Web Component `<simple-text>`.

## Field Definitions

### Einfache Felder

```javascript
// text-block.js
export const title = String;
export const content = String;
export const alignment = String; // "left", "center", "right"
```

### Komplexe Felder

```javascript
// gallery.js
export const images = Array;  // Array von Bild-Objekten
export const layout = String; // "grid", "carousel", "masonry"
export const columns = Number; // 2, 3, 4
```

### Validierung

```csv
# snippets.csv definiert Validierungsregeln
snippet_name,field_name,field_type,field_schema,required
hero-banner,title,String,"min:3;max:100",true
hero-banner,subtitle,String,"max:200",false
gallery,columns,Number,"min:1;max:6",true
```

## Snippet-Komposition

### Einfache Snippets

```tera
{# text-block.tera - Standalone #}
<text-block>
    <h2>{{ title }}</h2>
    <div class="content">{{ content|safe }}</div>
</text-block>
```

### Composite Snippets

```tera
{# text-with-image.tera - Komponiert aus anderen Snippets #}
<text-with-image class="layout-{{ layout }}">
    <div class="text-part">
        <text-block>{{ text_content }}</text-block>
    </div>
    <div class="image-part">
        <image-snippet>{{ image_content }}</image-snippet>
    </div>
</text-with-image>
```

## Theme Override System

Snippets können pro Theme überschrieben werden:

```bash
themes/corporate/hero-banner/hero-banner.tera     # Theme-spezifisch
themes/base/hero-banner/hero-banner.tera          # Fallback
snippets/hero-banner/hero-banner.tera             # Default
```

Das EPC-System (Explicit Path Chain) resolved automatisch die richtige Datei.

## Breakpoint System mit @scope

ReedCMS behandelt Breakpoints als First-Class Citizens:

```html
<!-- Standard Context -->
<body class="screen">
    <hero-banner>...</hero-banner>
</body>

<!-- WCAG Context -->
<body class="wcag">
    <hero-banner>...</hero-banner>
</body>

<!-- Mobile Context -->
<body class="phone">
    <hero-banner>...</hero-banner>
</body>
```

### CSS Organisation

```bash
snippets/hero-banner/
├── hero-banner.css        # Base styles mit @scope
├── hero-banner.wcag.css   # WCAG-spezifische Overrides (optional)
└── hero-banner.phone.css  # Mobile-spezifische Overrides (optional)
```

Die Breakpoints werden durch Klassen gesteuert, nicht durch Media Queries - das ermöglicht Server-Side Rendering optimiert für den jeweiligen Context.

## Performance-Optimierung

### Lazy Loading

```javascript
// Snippets werden erst geladen wenn benötigt
const snippetLoader = new SnippetLoader();
const snippetCache = new Map();

async function loadSnippet(name) {
    if (!snippetCache.has(name)) {
        const snippet = await snippetLoader.load(name);
        snippetCache.set(name, snippet);
    }
    return snippetCache.get(name);
}
```

### Bundle-Strategie

```rust
// Critical Snippets werden gebündelt
pub fn get_critical_snippets() -> Vec<&'static str> {
    vec!["hero-banner", "navigation-item", "text-block"]
}

// Andere werden on-demand geladen
pub fn is_critical(snippet_type: &str) -> bool {
    get_critical_snippets().contains(&snippet_type)
}
```

## KISS-Brain Philosophie

Das Snippet-System folgt der KISS-Brain Philosophie:

1. **Vorhersehbar:** Jedes Snippet ist automatisch eine Web Component
2. **Minimal:** Nur .tera und .css erforderlich, .js optional
3. **Deklarativ:** @component Directive statt JavaScript-Boilerplate
4. **Einheitlich:** Naming-Conventions ohne Ausnahmen
5. **Override-fähig:** Theme-System via EPC

"Jedes Snippet ist eine Web Component" - diese simple Regel macht ReedCMS mental vorhersehbar. Keine Überraschungen, keine Magie.

## Revolutionäre Einfachheit

Durch Rust-generierte Web Components erreichen wir:

1. **Zero JavaScript Boilerplate** - Entwickler schreiben nur Tera + CSS
2. **Garantierte Konsistenz** - Alle Components verhalten sich identisch
3. **Build-Zeit Optimierung** - Rust kann Components optimieren
4. **Type-Safety** - Field Definitions werden zur Build-Zeit validiert
5. **Kleinste Bundle Size** - Nur genutzter Code wird generiert

Ein Entwickler muss nur noch:
```tera
{# @component name: "my-feature" #}
<my-feature>{{ content }}</my-feature>
```

Fertig. Rust macht den Rest.